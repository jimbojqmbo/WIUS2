#version 330 core

// Interpolated values from the vertex shaders
in vec3 vertexPosition_cameraspace;
in vec3 fragmentColor;
in vec3 vertexNormal_cameraspace;
in vec2 texCoord;

// Ouput data
out vec3 color;
out vec4 FragColor;

struct Light {
	int type;
	vec3 position_cameraspace;
	vec3 color;
	float power;
	float kC;
	float kL;
	float kQ;
	vec3 spotDirection;
	float cosCutoff;
	float cosInner;
	float exponent;
};

struct Material {
	vec3 kAmbient;
	vec3 kDiffuse;
	vec3 kSpecular;
	float kShininess;
};

float getAttenuation(Light light, float distance) {
	if(light.type == 1)
		return 1;
	else
		return 1 / max(1, light.kC + light.kL * distance + light.kQ * distance * distance);
}

float getSpotlightEffect(Light light, vec3 lightDirection) {
	vec3 S = normalize(light.spotDirection);
	vec3 L = normalize(lightDirection);
	float cosDirection = dot(L, S);
	//return smoothstep(light.cosCutoff, light.cosInner, cosDirection);
	if(cosDirection < light.cosCutoff)
		return 0;
	else
		return 1; //pow(cosDirection, light.exponent);
}

// Constant values
const int MAX_LIGHTS = 8;

// Values that stay constant for the whole mesh.
uniform bool lightEnabled;
uniform Light lights[MAX_LIGHTS];
uniform Material material;
uniform int numLights;
uniform bool colorTextureEnabled;
uniform sampler2D colorTexture;

// Fog uniforms
uniform bool fogEnabled;
uniform float fogStart; // distance at which fog begins
uniform float fogEnd;   // distance at which fog is fully opaque
uniform vec3 fogColor;  // color to blend to

void main()
{
    vec4 baseColor;

    if(lightEnabled)
    {
        vec3 materialColor;
        if(colorTextureEnabled)
            materialColor = texture(colorTexture, texCoord).rgb;
        else
            materialColor = fragmentColor;

        vec3 E = normalize(-vertexPosition_cameraspace);
        vec3 N = normalize(vertexNormal_cameraspace);

        vec3 result = materialColor * material.kAmbient;

        for(int i = 0; i < numLights; ++i)
        {
            vec3 lightDir = lights[i].position_cameraspace - vertexPosition_cameraspace;
            float dist = length(lightDir);
            vec3 L = normalize(lightDir);

            float diff = max(dot(N, L), 0.0);
            vec3 R = reflect(-L, N);
            float spec = pow(max(dot(E, R), 0.0), material.kShininess);

            float att = getAttenuation(lights[i], dist);

            result += materialColor * material.kDiffuse * diff * lights[i].color * lights[i].power * att;
            result += material.kSpecular * spec * lights[i].color * lights[i].power * att;
        }

        baseColor = vec4(result, 1.0);
    }
    else
    {
        if(colorTextureEnabled)
            baseColor = texture(colorTexture, texCoord);
        else
            baseColor = vec4(fragmentColor, 1.0);
    }

    // Apply fog based on camera-space distance
    if (fogEnabled)
    {
        float dist = length(vertexPosition_cameraspace);
        // smooth factor from 0 (no fog) to 1 (full fog)
        float f = 0.0;
        if (fogEnd > fogStart)
            f = smoothstep(fogStart, fogEnd, dist);
        else
            f = (dist >= fogEnd) ? 1.0 : 0.0;

        FragColor = mix(baseColor, vec4(fogColor, baseColor.a), f);
    }
    else
    {
        FragColor = baseColor;
    }
}